---
layout:     post                    # 使用的布局（不需要改）
title:      信号处理函数是怎么被系统调用的               # 标题 
subtitle:     #副标题
date:       2017-7-16              # 时间
author:     co                      # 作者
header-img: img/post-bg-2015.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - linux
---

## 分析场景
当我们调用read函数等待一个用户输入，如果等待了一分钟，依然没有输入，那么结束等待。这里我们代码如下。

```
static void sig_alrm(int);
int

main(void)
{
	int  n;
	char  line[MAXLINE];
	if (signal(SIGALRM, sig_alrm) == SIG_ERR)
	err_sys("signal(SIGALRM) error");
	alarm(60);
	if ((n = read(STDIN_FILENO, line, MAXLINE)) < 0)
	err_sys("read error");
	alarm(0);

	exit(0);
}

static void
sig_alrm(int signo)
{
/* nothing to do, just return to interrupt the read */
}
```
## 分析
> cpu的状态分为两种：内核模式和用户模式。
> 内核模式的进入和退出的指令 sysenter sysexit

- 一般情况下进程执行到某位置 pos，突然收到信号，则会转去执行信号处理代码，之后返回之前pos继续执行
- 我们这里说的是当调用系统函数时，中间收到信号是如何处理的。

图片-1
参考上图和代码分析。假设只有两个进程在运行。调用read前，开启闹钟。调用read，执行sysenter指令进入cpu内核状态，然后调用真正的读取函数，sys_read。当一直没有用户输入，也就是进入阻塞，进程a会执行调度把cpu让出。这时候进程b开始执行。进程b也会因为资源问题阻塞。当进程a收到闹钟信号时，
---------------

信号号称所谓软中断，事实上，还是没有真正的硬件中断那样能随时改变cpu的执行流

硬件中断之所以能一发生就得到处理是因为处理器在每个指令周期的结尾都会去检查中断，这种粒度是很细的

但是信号的实现只是在进程的task_struct里面有一个成员用于标识当前收到了哪些信号？

而这个成员的检查显然只能在特定时间点：从内核模式返回到用户模式的时候

可以想象，当进程从一个硬件中断中返回、从系统调用中返回或者正在休眠或者刚刚得到了调度，都是从内核态返回用户态的时机

这时候就会检查pending signals，注意信号处理函数的调用也看成是在内核态的，也就是如果累计了多个信号会一直处理完才返回用户态。

所以永远不要指望你所发送的信号能像硬件中断那般随时处理！


-----------
内核如何向一个进程发送信号:
内核给一个进程发送软中断信号的方法，是在进程所在的进程表项的信号域设置对应于该信号的位。
如果信号发送给一个正在睡眠的进程，那么要看该进程进入睡眠的优先级，如果进程睡眠在可被中断的优先级上，则唤醒进程；否则仅设置进程表中信号域相应的位，而不唤醒进程。

内核在什么时机处理:
进程检查是否收到信号的时机是：一个进程在即将从内核态返回到用户态时；或者，在一个进程要进入或离开一个适当的低调度优先级睡眠状态时。 
内核处理一个进程收到的信号的时机是在一个进程从内核态返回用户态时,或者，在一个进程要进入或离开一个适当的低调度优先级睡眠状态时。
所以，当一个进程在内核态下运行时，软中断信号并不立即起作用，要等到将返回用户态时才处理。进程只有处理完信号才会返回用户态，进程在用户态下不会有未处理完的信号。
----------