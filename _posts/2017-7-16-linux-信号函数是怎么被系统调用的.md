---
layout:     post                    # 使用的布局（不需要改）
title:      信号处理函数是怎么被系统调用的               # 标题 
subtitle:     #副标题
date:       2017-7-16              # 时间
author:     co                      # 作者
header-img: img/post-bg-2015.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - linux
---

## 信号的产生
- 在终端通过键盘输入产生信号 比如 ctrl+c 产生 sigint信号
- 通过kill函数产生。当然在shell里面通过skill命令发送的信号也是调用kill函数产生的。
- 通过alarm函数产生。也就是定时器闹钟。
- 系统条件触发产生。比如运算时发现除数为0，访问虚拟内存的时候发现权限不够，socket读端已经关闭而写端还在继续写。

## 信号的阻塞
在pcb中有专门给信号做记录的内存。主要有两个集合。
- 信号屏蔽集合
- 信号挂起集合

我们一般说信号被处理了，是指信号已经被信号处理函数处理了，说pending状态是指，pcb已经被设置了信号位，处理等待后面的处理状态。有时候我们想屏蔽某些信号，也就是到收到某些信号时，暂时不处理，那么就需要设置屏蔽信号集。这样就算收到了被屏蔽的信号，也不会被处理。这时候挂起集和里面这个信号位也被设置了，表示收到了。只要调用取消屏蔽信号的对应函数数sigprocmask，信号就会被处理，之后数sigprocmask才返回。这里需要注意时序。关于相关函数的运用这里就不说了，主要说原理。

```
int sigemptyset(sigset_t *set);
int sigfillset(sigset_t *set);
int sigaddset(sigset_t *set, int signo);
int sigdelset(sigset_t *set, int signo);
int sigismember(const sigset_t *set, int signo)

int sigprocmask(int how, const sigset_t *set, sigset_t *oset); 屏蔽集设置
int sigpending(sigset_t *set);	--查看挂起的信号集
int sigaction(int signo, const struct sigaction *act, struct sigaction *oact); --设置捕捉动作
```


## 信号的调用时机
硬件中断可以认为的及时的。因为系统收到信号后，会在cpu执行指令间隔查询是否有硬件中断。粒度很小，所以可以认为是瞬时处理的。我们这里说的软中断并不是实时处理。举个例子。调用pause使用进程进入休眠状态。如果收到一个信号，那么执行流如下
- 在进程的pcb的设置信号标志位 
- 如果进程被系统调度则查看是否有信号 有则调用信号处理函数处理 这里是切换到用户态
- 处理完成后切回到内核态 
- 返回到用户态
- pause返回-1

这里面调用信号处理函数的时机是在内核态切换到用户态间隙。而且需要进程刚好被调度到，如果没有被系统调度，那么信号还是保存在进程的pcb中。一般来说信号处理函数被调用的时机主要是当进程从一个硬件中断中返回、从系统调用中返回或者正在休眠或者刚刚得到了调度。

## 结束