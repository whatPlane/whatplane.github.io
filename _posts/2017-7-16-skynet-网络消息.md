---
layout:     post                    # 使用的布局（不需要改）
title:      网络消息              # 标题 
subtitle:     #副标题
date:       2017-7-17              # 时间
author:     co                      # 作者
header-img: img/post-bg-2015.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - skynet源码分析
---
#### 网络处理初始化 
网络开启 skynet_socket_init .skynet_socket内部是使用 socket_server。初始化网络主要做了下面几件事
- 产生一个epoll例程
- 产生一对管道描述符。分别是写和读。同时把读描述符加入epoll
- 初始化 socket_server 结构体，我们叫他网络总管吧。内部有一个数组slot，里面是大量的预分配的socket结构体，用于将来处理每一个连接用。
- 每个socket 结构体。主要成员有 在slot的槽位id 和 发送数据缓冲区。  

注意下面针对结构体的注释
```
struct socket {
	uintptr_t opaque;	对应服务的handle
	struct wb_list high; 高优先级发送数据链表
	struct wb_list low;  低优先级发送数据链表
	int64_t wb_size;
	uint32_t sending;
	int fd;
	int id; 在slot里面的槽位
	uint8_t protocol;
	uint8_t type; 当前socket的一个类型记录
	uint16_t udpconnecting;
	int64_t warn_size;
	union {
		int size;
		uint8_t udp_address[UDP_ADDRESS_SIZE];
	} p;
	struct spinlock dw_lock;
	int dw_offset;
	const void * dw_buffer; 直接写数据buffer
	size_t dw_size;
};


struct socket_server {
	int recvctrl_fd;
	int sendctrl_fd;
	int checkctrl;
	poll_fd event_fd;
	int alloc_id; 当前已经被使用的 socket 计数
	int event_n;
	int event_index;
	struct socket_object_interface soi;
	struct event ev[MAX_EVENT];
	struct socket slot[MAX_SOCKET]; slot数组
	char buffer[MAX_INFO];
	uint8_t udpbuffer[MAX_UDP_PACKAGE];
	fd_set rfds;
};
```
这里是初始化调用的函数代码
```
skynet_socket_init() {
	SOCKET_SERVER = socket_server_create();
}

socket_server_create() {
int i;
	int fd[2];
	poll_fd efd = sp_create();//产生epoll例程

	if (pipe(fd)) {//产生管道
	
	}
	if (sp_add(efd, fd[0], NULL)) {//把管道的读端加入epoll
	
	}

	struct socket_server *ss = MALLOC(sizeof(*ss));//分配大量堆空间
	ss->event_fd = efd;
	ss->recvctrl_fd = fd[0];
	ss->sendctrl_fd = fd[1];
	ss->checkctrl = 1;

	for (i=0;i<MAX_SOCKET;i++) { //提前分配大量的socket
		struct socket *s = &ss->slot[i];
		s->type = SOCKET_TYPE_INVALID; //类型都设置为无效
		clear_wb_list(&s->high);
		clear_wb_list(&s->low);
	}
	ss->alloc_id = 0; //设置已经被占用的socket计数
	ss->event_n = 0;
	ss->event_index = 0;
	memset(&ss->soi, 0, sizeof(ss->soi));
	FD_ZERO(&ss->rfds);
	assert(ss->recvctrl_fd < FD_SETSIZE);

	return ss;
}

```

#### 网络处理线程
```
static void *
thread_socket(void *p) {
	struct monitor * m = p;
	skynet_initthread(THREAD_SOCKET);
	for (;;) {
		int r = skynet_socket_poll();//这里不断的处理epoll事件
		if (r==0)
			break;
		if (r<0) {
			CHECK_ABORT
			continue;
		}
		wakeup(m,0);
	}
	return NULL;
}
```
我们从lua层监听分析起。lua层调用 `local lID = socket.listen(addr)`对应的底层c函数的位置在 lua-socket.c文件。比如 addr = "0.0.0.0:8001"
```
static int
llisten(lua_State *L) {
	const char * host = luaL_checkstring(L,1);
	int port = luaL_checkinteger(L,2);
	int backlog = luaL_optinteger(L,3,BACKLOG);
	struct skynet_context * ctx = lua_touserdata(L, lua_upvalueindex(1));//这里获得了发起监听的服务
	int id = skynet_socket_listen(ctx, host,port,backlog);//这里开始调用监听
	if (id < 0) {
		return luaL_error(L, "Listen error");
	}

	lua_pushinteger(L,id);
	return 1;
}

skynet_socket_listen(struct skynet_context *ctx, const char *host, int port, int backlog) {
	uint32_t source = skynet_context_handle(ctx);//保存了发起监听的服务
	return socket_server_listen(SOCKET_SERVER, source, host, port, backlog);
}

```
上面的 SOCKET_SERVER 就是我们的网络处理总管。
### 结束