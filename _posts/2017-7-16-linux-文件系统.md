---
layout:     post                    # 使用的布局（不需要改）
title:      文件系统              # 标题 
subtitle:     #副标题
date:       2017-7-17              # 时间
author:     co                      # 作者
header-img: img/post-bg-2015.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - 网络
---

## 目的
更清楚的了解文件系统，理解相关的原理和结构，知道系统调用到底做了什么。

## 磁盘的分区
一般我们要使用一个磁盘，首先我们分区，对每个分区我们要进行格式化得到文件系统。因为格式的不同，造成了不同的文件系统。下面是ext2文件系统的样子。
![](https://gitee.com/whatplane/resource/raw/master/img/co_20190401140545.png)
一个分区主要由块（block）组成，即块是最小的单位。分区主要分为启动块和块组（block group）。这里主要说明块组。
- 超级块（super block） ，用来保存文件系统的类型，版本，块大小
- 组描述符表（group desription table），表里面的每一项对应说明一个组块。比如块位图起始位置，inode位图起始位置，inode表的个数，块的个数
- 块位图（block bitmap），占用一个块大小。里面的内容是类似这样00000111100000011。每一个位对应一个块，1表示块被使用，0表示空闲。块的大小是分区开始的时候决定的，一般设置为1024字节或者2048字节 4096字节。因为块的大小是固定了，所以位的个数也就固定的。所以整个block group总共分配的block也是固定的。因为整个分区的大小是已知的，所以可以确定应该划分多少个块组。
- inode bitmap，这里也是占用一个块。里面都是000111001...这样的。每一个位对应一个inode。这样说来inode的数量也是固定的。那每个inode占用多少个块呢？在分配的时候会根据一定的策略分配。因为我们文件系统主要还是用来存数据的，首要考虑是尽量多分配数据块。下面分析两个场景：当你分区都是很大的文件，比如说高清电影，那么留给inode的空间就很少，所以每个inode占用的块就应该设置少一点，如果分区都是大量很小的文件，如果每个inode占用的块数量很大，那么导致有很多小文件分配不到inode，这样就浪费了数据块，因为我们知道每一个文件必须有对应的inode。
- inode table 里面存放的是一个个inode。
- data block 是数据块。

## inode
一个文件对应一个inode。inode的是对文件的描述信息。或者我们认为一个文件在逻辑上分为两部分，一个是inode，一个数据块。我们使用 `ls -l`命令的时候，显示出来内容，除了文件名外，都是属于inode的信息。比如说有权限，大小，硬链接个数。inode还有一个重要的地方是有块索引数组，通过索引数组找到这个文件的块数据。简单的理解可以是这样，一个索引数组大小是15，每个索引占用4字节，前面12个索引分别指向一个块，后面三个索引叫做一级间接索引，二级间接索引，三级间接索引。如果15个索引都是分别指向一个块，那么一个文件能够存的最大数据岂不是只有15个块了，而我们一般定义一块是1024字节，也就是说一个文件最大只有15kb，显然不可能。后面的三个索引给了我们答案。前面12个索引分别指向一个块，一级间接索引也指向一个块，但是块里面存放的还是是索引。这个块大小如果是b，因为每个索引占用4字节，所以这个块可以指向b/4个块，这时块里面存放的是真正的数据。同理二级间接索引就可以理解了。

## 文件的类型
文件的类型主要分为
- 常规文件 有数据块和inode
- 目录  目录的数据块主要存放的是该目录下文件记录，每个记录主要有文件的名字和inode号，这样通过inode号可以找到对应的inode节点。
- 符号链接 也就是我们常说的软链接文件。这个文件的inode里面存放的就是真正的文件的路径。比如ln -s ./cobook book。当然如果文件的路径很长，则会分配数据块，存放路径。
- 设备文件 管道文件 sock文件 ，这三种文件都没有数据块。

## 怎么获取一个文件的inode
比如通过stat函数获取（/co/apps/a.out）的inode。首先我们获取根inode，这个一般在磁盘mount到目录的时候，就已经固定了根inode的位置。所以直接可以找到根inode。然后在根inode对应的数据块中找到co的记录，从中提取inode号，然后找到co的inode，然后继续重复找，最后找到a.out的inode。

## vfs
上面说是ext2文件系统，实际上还有其他文件系统，格式可能不一样，但是操作系统通过一层抽象，屏蔽了一些差异，对程序员来说是透明的，只是上面的那些概念我们还是可以在vfs（虚拟文件系统）中找到。比如硬件的inode在vfs中也有对应的inode。

## 软连接 和 硬链接
- 在cd到某个目录，`ls -l`展示的链表的第二栏就是硬链接个数。硬链接就是文件的别名。比如你有同事叫王林，大家也叫他老王。其实是同一个人。为什么要硬链接呢，可以认为就是引用计数。当发现引用计数为0的时候，那么释放文件的时候，就真正删除了。**注意**:一个目录下的 `.`就是一个这个目录文件的别名。下面观察一下我的co目录。
![](https://gitee.com/whatplane/resource/raw/master/img/wx_20190401150926.png)
这里显示co目录有6个硬链接。除了co目录和co目录下的 `.`，还有四个的地方。我们进入co目录下发现，里面又有4个目录。这个四个目录里面都有`..`文件，都是引用co目录。
![](https://gitee.com/whatplane/resource/raw/master/img/wx_20190401151032.png)

- 软链接 实际上就是一个快捷方式。我们产生一个软链接就是新建了一个文件，这个文件跟软链接所指的那个文件，拥有不同的inode。本质上就是两个不同的文件。而硬链接的不同文件都是拥有同一个inode，只是修改了iNode的硬链接个数。

## 关于打开同一个文件
每次调用系统函数open打开一个文件，就会产生一个对应的 file 结构。通过这个结构可以的操作：
- 对块数据进行处理 就是我们常见对文件数据进行读写的函数调用比如 read write
- 对inode进行处理 就是我们的修改inode的函数比如 chmod stat等。

![](https://gitee.com/whatplane/resource/raw/master/img/wx_20190401154408-min.png)

***
必要的解释：
- f_pos 是文件读写的位置
- f_count 是对文件描述符的引用个数。比如在进程打开了一个文件，那么引用为1，如果fork了一个子进程，那么这个引用为2.
- f_dentry  主要是一个对inode查找的缓存。上文解释过查找一个文件的inode的过程。file里面主要有类操作，也解释了。
- 对同一个多次调用open打开，会创建多个file结构，只是他们的inode是相同的。


## 结束