---
layout:     post                    # 使用的布局（不需要改）
title:      进程               # 标题 
subtitle:     #副标题
date:       2017-7-16              # 时间
author:     co                      # 作者
header-img: img/post-bg-2015.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - linux
---
## 进程的内存布局

![](https://gitee.com/whatplane/resource/raw/master/img/wx_20190313160941-min.png)
- 栈的增长方向是高地址朝低地址
- 正文就是代码
- 初始化的数据就是我们定义常量
- 未初始化的数据就是那些只定义了，但是没有赋值的数据。最后在调用exec的时候会赋值0.这样做是减小elf文件的空间占用


## 进程环境
shell进程在用户登录的时候已经设置了相关的环境。比如说 HOME PATH等。而通过shell执行一个程序，则会继承者这些环境。当然新的程序，也就是进程可以更改这些环境，从此与父进程环境独立开来。
## 进程控制
- 进程的产生

对进程的控制是通过一个结构体task_struct，我们也叫pcb，即进程控制块。产生一个进程主要是通过fork函数，当然我们习惯是fork+exec函数配合用。fork采用写时复制技术来copy父进程。也就是fork的子进程并不是一次性完全的把父进程copy过来，而是当任意一方有写操作时候，才另行分配空间。fork是耗时的，比如说在redis做备份的时候，就可以体现出来。备份的时候，要保证父进程尽量少进行写操作，否则可能导致马上分配大量子进程空间，导致内存不足问题。进程fork中需要关注的属性是 文件描述符表 和信号。我们会在子进程中继续使用父进程中打开的文件。比如父子进程单向通讯的管道。父进程关闭读，子进程关闭写。文件被关闭的唯一条件是引用计数为0。
> 在进程还没有运行时不会被信号打断。

图-文件描述表
![](https://gitee.com/whatplane/resource/raw/master/img/wx_20190225172216-min.png)
  - f_count 就是文件的引用计数
  - f_pos 读写文件的位置
  - f_inode 对应的是文件系统


- 进程的结束

父进程如果先于子进程退出，那么子进程变成孤儿进程，被init进程认领，即init成为父进程。如果子进程先于父进程退出，父进程没有调用wait回收子进程的pcb资源，那么子进程会变成僵尸进程，占用的资源无法释放。当然如果此时父进程退出，那么最终还是会被init认领。问题在于在实际编程中，父进程一般是一直存在的，那么僵尸子进程占用的资源一直无法回收。



## 进程间通讯 ipc

- 管道


管道的有四种情况，非阻塞下的读写。这个在socket编程中也具有普遍意义。
  - 读端情况1：当写端已经关闭，在读端继续读，如果管道中还有数据，那么先读完，直到返回0
  - 读端情况2：当写端没有关闭，但是也没有继续写数据，如果管道中还有数据，那么先读完，知道最后阻塞读端
  - 写端情况1：当读端已经关闭，写端继续写数据，怎产生sigpip信号，默认处理是终止程序。所以网络程序中经常忽略这个sigpipe信号。因为如果客户端已经断开连接，而服务器依然在往对应的socket写数据。
  - 写端情况2：当读端没有关闭，但是没有继续读数据，如果管道还有空间可以写数据，那么写端继续写，直到没空间写，然后阻塞

- mmap 设置一块共享内存共多个进程访问
- 还有其他信号量 队列这些，这里不做讨论。

## 结束