---
layout:     post                    # 使用的布局（不需要改）
title:      进程               # 标题 
subtitle:     #副标题
date:       2017-7-16              # 时间
author:     co                      # 作者
header-img: img/post-bg-2015.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - linux
---

## 进程环境
shell进程在用户登录的时候已经设置了相关的环境。比如说 HOME PATH等。而通过shell执行一个程序，则会继承者这些环境。当然新的程序，也就是进程可以更改这些环境，从此与父进程环境独立开来。
## 进程控制
- 进程的产生

对进程的控制是通过一个结构体task_struct，我们也叫pcb，即进程控制块。产生一个进程主要是通过fork函数，当然我们习惯是fork+exec函数配合用。fork采用写时复制技术来copy父进程。也就是fork的子进程并不是一次性完全的把父进程copy过来，而是当任意一方有写操作时候，才另行分配空间。fork是耗时的，比如说在redis做备份的时候，就可以体现出来。备份的时候，要保证父进程尽量少进行写操作，否则可能导致马上分配大量子进程空间，导致内存不足问题。进程fork中需要关注的属性是 文件描述符表 和信号。我们会在子进程中继续使用父进程中打开的文件。比如父子进程单向通讯的管道。父进程关闭读，子进程关闭写。文件被关闭的唯一条件是引用计数为0。
> 在进程还没有运行时不会被信号打断。

图-文件描述表

- 进程的结束

父进程如果先于子进程退出，那么子进程变成孤儿进程，被init进程认领，即init成为父进程。如果子进程先于父进程退出，父进程没有调用wait回收子进程的pcb资源，那么子进程会变成僵尸进程，占用的资源无法释放。当然如果此时父进程退出，那么最终还是会被init认领。问题在于在实际编程中，父进程一般是一直存在的，那么僵尸子进程占用的资源一直无法回收。



## 进程关系