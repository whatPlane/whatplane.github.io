---
layout:     post                    # 使用的布局（不需要改）
title:      进程关系               # 标题 
subtitle:     #副标题
date:       2017-7-16              # 时间
author:     co                      # 作者
header-img: img/post-bg-2015.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - linux
---
## 从远程登录开始
我们经常用远程工具登录linux。一般是输入帐号密码，之后则会出现shell命令提示，表示可以正式开始进行后续操作了。这里讨论下telnet的连接过程。实际上分为几个步骤
- 系统启动的时候，init进程会启动一个shell进程，然后执行配置脚本去启动一个进程systemd （我的系统是centos7.2，其他系统可能不一样）
- 当telnet客户端发起连接的时候，systemd会产生一个服务器进程telnet来专门处理这次连接。
- telnet会打开一个伪终端。（这里我们暂时就认为他是一个终端）
- 之后login程序做登录验证处理。如果成功则设置进程的用户id，组id，建立用户目录等。
- 最终login调用 exec产生shell进程。
> login程序做的设置进程用户id，组id等操作，都是通过登录用户的配置文件/etc/passwd 获取到的。当然最后产生的那个shell进程也是读取的配置文件。

这里的组id是进程的属性，主要目的是用来访问保护的资源。跟后面我们即将讨论的，关于会话，作业的进程组id完全无关。
[访问被保护的文件](https://whatplane.github.io/2017/07/16/linux-%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/)


## 孤儿进程
> 一个父进程已经终止的进程，叫做孤儿进程

孤儿进程就是没有父进程吗？并不是。成为孤儿进程后，他的父进程是init进程。这里的孤儿进程应该理解为死了亲爹，但是有继父。

## 孤儿进程组
该进程组的每个成员的父进程要么是该组的成员，要么不在该成员所属的会话中。这个典型的例子就是守护进程。

## 会话 进程组 
一个会话由多个进程组构成。即一个前台进程组和多个后台进程组。产生会话的进程叫做控制进程，叫会话长，也叫session leader。
![](https://gitee.com/whatplane/resource/raw/master/img/bk_20190220124632-min.png) 
我们的登录shell可以看做是一个会话。不输入命令行时，会话只有一个进程组，其中只有一个成员，就是shell进程。如果我们输入`ps|cat`命令，那么就有两个进程组了，`ps和cat`则同处一个进程组。注意pgid表示进程组id。此时`ps 和cat`属于前台进程组，shell进程属于后台进程组。前台进程组里面的所有进程可以收到终端的键盘输入和终端产生的信号。
> ctrl + z 暂停
> ctrl + c 中断
> ctrl+ \ 退出


![](https://gitee.com/whatplane/resource/raw/master/img/ll_20190220131028-min.png) 
后台进程组只有在变成孤儿进程组，并且成员被暂停时，才能收到sighup信号（这里也是守护进程一般要捕获sighup信号的原因）。
一般来说一个终端对应一个会话（当然一个会话也可以没有终端，比如守护进程所属的会话）。

## 前台进程组可以通过程序进行设置
tcsetpgrp 可以设置前台进程组。
伪代码如下：
```
void handler(int sig) {
}
int main(int argc, char* argv[]) {
	signal(SIGHUP, handler);
	tcsetpgrp(0, getppid());
	while(1) sleep(1);
	return 0;
}
```
编译上面的程序，假设生成执行文件test。通过shell执行。那么在终端输入 ctrl+c或者 ctrl+z ，该test程序都不会有任何反应。因为前台进程组被设置成了跟shell进程一组了，而一个会话只能有一个前台进程组，所以test成为了后台进程组，那么就收不到终端的信号了

## 守护进程
> 有时候，我们希望进程不和任何控制终端挂钩，即使你关闭终端对它也没有任何影响。另外我们不希望这种进程向终端读写数据（需要关闭标准输入、标准输出和标准错误），它会一直在后台运行着，像这种进程，称之为**守护进程**。

当我们关闭终端的时候，所有前台进程组都会收到**sighup**信号。当然控制进程也会。比如我们的shell进程。那么后台进程组会不会也收到**sighup**信号呢？因为父进程shell已经终止，这时候后台进程组变成了孤儿进程组，如果有成员处于停止状态，那么就会收到**sighup**信号，**sighup**信号的默认处理就是终止程序。使用守护进程需要单独处理**sighup**信号。

## 守护进程的一个实现
注意**调用setsid的进程不能是一个进程组的组长**。